{"meta":{"title":"空脑壳","subtitle":"Over the mountains, mountains.","description":"Over the mountains, mountains.","author":"雷雷雷","url":"http://hi.thisisray.me"},"pages":[{"title":"categories","date":"2018-01-29T10:34:19.000Z","updated":"2018-10-08T03:26:35.146Z","comments":true,"path":"categories/index.html","permalink":"http://hi.thisisray.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-29T09:15:12.000Z","updated":"2018-10-08T03:26:35.146Z","comments":true,"path":"tags/index.html","permalink":"http://hi.thisisray.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"config git autocomplete in terminal on macOS","slug":"config-git-autocomplete-in-terminal-on-macOS","date":"2018-06-29T07:45:33.000Z","updated":"2018-10-08T03:26:35.142Z","comments":true,"path":"config-git-autocomplete-in-terminal-on-macOS.html","link":"","permalink":"http://hi.thisisray.me/config-git-autocomplete-in-terminal-on-macOS.html","excerpt":"mac 上的 terminal 竟然不支持 git 指令自动补全（应该不是个人原因），这对于使用 git 管理代码的程序员或多或少是个麻烦，当然解决方案也很简单。 123系统环境： macOS Hign Sierra version: 10.13.5","text":"mac 上的 terminal 竟然不支持 git 指令自动补全（应该不是个人原因），这对于使用 git 管理代码的程序员或多或少是个麻烦，当然解决方案也很简单。 123系统环境： macOS Hign Sierra version: 10.13.5 下载 bash 文件1curl -O https://raw.github.com/git/git/master/contrib/completion/git-completion.bash 可能是自己网络的原因，通过上述指令下载下来的文件总是空文件。和我一样的同学可以直接将链接粘贴到浏览器地址栏，然后 cmd + A &amp; cmd + C 。 找一个喜欢的文件夹，新建 .bash 文件，并将刚才的内容粘贴进文件中。 source 打开 terminal 一路 cd 定位到刚才的文件位置 运行 source &lt;filename&gt; 重启 terminal done! referenceautocompelet git on mac OS","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"},{"name":"系统配置","slug":"系统配置","permalink":"http://hi.thisisray.me/tags/系统配置/"}]},{"title":"Javascript 词法作用域和动态作用域","slug":"Javascript-词法作用域和动态作用域","date":"2018-05-28T02:24:28.000Z","updated":"2018-10-08T03:26:35.141Z","comments":true,"path":"Javascript-词法作用域和动态作用域.html","link":"","permalink":"http://hi.thisisray.me/Javascript-词法作用域和动态作用域.html","excerpt":"","text":"作用域（scope） 作用域是 定义变量的区域， 规定了如何查找变量（即正在执行的代码对变量的访问权限） Javascript 采用 词法作用域（即 静态作用域） ##","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"[译] 何时 merge 与何时 rebase","slug":"译-何时-merge-与何时-rebase","date":"2018-05-22T03:35:49.000Z","updated":"2018-10-08T03:26:35.145Z","comments":true,"path":"译-何时-merge-与何时-rebase.html","link":"","permalink":"http://hi.thisisray.me/译-何时-merge-与何时-rebase.html","excerpt":"","text":"","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"}]},{"title":"各终端 Terminal 添加 git 分支名称","slug":"各终端-Terminal-添加-git-分支名称","date":"2018-04-27T09:39:51.000Z","updated":"2018-10-08T03:26:35.144Z","comments":true,"path":"各终端-Terminal-添加-git-分支名称.html","link":"","permalink":"http://hi.thisisray.me/各终端-Terminal-添加-git-分支名称.html","excerpt":"在终端进行 git 操作的时候，难免会进行分支的切换。切来切去的就会忘记当前所在的分支了。下面我们就在终端中加入 git 的分支信息。","text":"在终端进行 git 操作的时候，难免会进行分支的切换。切来切去的就会忘记当前所在的分支了。下面我们就在终端中加入 git 的分支信息。 Mac OS在 ~/.bash_profile 文件中添加以下代码： 12345# Show current git branch nameparse_git_branch() &#123; git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/'&#125;export PS1=\"\\u@\\h \\[\\033[32m\\]\\w\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \" Ubuntu在 ~/.bashrc 文件中添加以下代码： 123456789101112# Show git branch name force_color_prompt=yes color_prompt=yes parse_git_branch() &#123; git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/(\\1)/' &#125; if [ \"$color_prompt\" = yes ]; then PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[01;31m\\]$(parse_git_branch)\\[\\033[00m\\]\\$ ' else PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w$(parse_git_branch)\\$ ' fi unset color_prompt force_color_prompt referenceGit branch name in Linux/Mac Terminal","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"}]},{"title":"Angular Directive","slug":"Angular-Directive","date":"2018-04-27T05:54:54.000Z","updated":"2018-10-08T03:26:35.139Z","comments":true,"path":"Angular-Directive.html","link":"","permalink":"http://hi.thisisray.me/Angular-Directive.html","excerpt":"翻译自 Directives","text":"翻译自 Directives 隔离指令的作用域(scope)我们上面的 myCustomer 指令已经很棒了，但是它有个致命的缺陷：只能在给定的作用域里使用它一次。 上述的缺陷就导致了需要去额外创建多个不同的 controller 来达到复用指令的目的。这显然不是好的解决方案。 我们想要做到的是将外部作用域与内部的作用域分离，然后将外部指令映射到内部指令上。这就用到了指令的 scope 属性。 在 index.html 中第一个 &lt;my-customer&gt;&lt;/my-customer&gt; 元素将 info 属性绑定了 naomi 的值，这是我们已经在 controller 中暴露出来的。第二个则是绑定到了 igor。 总而言之，在一个 controller 中想要复用同一个 directive 就需要在 directive 中添加 scope 属性 让我们仔细地分析一下 scope 这个属性： 12345// ...scope: &#123; customerInfo = '=info'&#125;// ... scope 属性是一个对象，内容是用于绑定独立作用域。具体如下： key 是用于绑定指令的独立作用域的名字 value 则是告诉 angular 的 $compile 在编译的时候将哪个值与视图绑定。 注意： 这些 ＝attr 属性就像指令名称一样被标准化。将这些属性绑定到元素上时 &lt;div bind-to-this=&#39;thing&#39;&gt; 需要这样指定 =bindToThis 如果属性名和和属性值一样，则可以直接使用 = 绑定 1234scope: &#123; // 等同于 =customer customer: '='&#125; 除了使从指令内部绑定不同作用域数据成为可能以外，使用 isolate scope 还有另外的影响。 就像名字建议的那样，指令的 scope 隔绝了一切除了明确添加到 scope: {} 对象中的和 models。这对于构建可复用的组件是很有帮助的，因为这阻止了一个组件意外的更改 model 中的属性","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hi.thisisray.me/tags/AngularJS/"}]},{"title":"webpack series","slug":"webpack-series","date":"2018-04-24T13:46:57.000Z","updated":"2018-10-08T03:26:35.143Z","comments":true,"path":"webpack-series.html","link":"","permalink":"http://hi.thisisray.me/webpack-series.html","excerpt":"买了本掘金小册 《使用 webpack 定制前端开发环境》，决定跟着学一遍 webpack。在此不定期打卡记录一下。","text":"买了本掘金小册 《使用 webpack 定制前端开发环境》，决定跟着学一遍 webpack。在此不定期打卡记录一下。 webpack 的概念和基础使用loaderwebpack 使用 loader 将不同格式的文件转换为 webpack 所支持的 模块。 支撑着 webpack 处理文件的多样性。 plugin用于处理 loader 功能以外的其他任务，例如： 压缩 JS webpack 如何解析代码模块路径\b常用的几个如下方代码里所注释的： 123456789101112131415161718192021module.exports = &#123; ... resolve: &#123; // import 时的代号，顾名思义是针对于 js 文件的模块引用 alias: &#123; utils: path.resolve(__dirname, 'src/utils'), log$: path.resolve(__dirname, 'src/utils/log.js') &#125;, // 用于 import 模块时自动匹配后缀名称 extensions: ['.js', '.json', '.jsx', '.css', '.less'], // modules 顾名思义为 node 的模块，所以默认就为当前文件下的 node_modules 文件夹。 // 此处写绝对路径的原因是为了导出的时候更加方便查找减少时间 modules: [ path.resolve(__dirname, 'node_modules') ] &#125; ...&#125;","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://hi.thisisray.me/tags/webpack/"}]},{"title":"Dive into FE-router","slug":"Dive-into-FE-router","date":"2018-04-24T09:57:31.000Z","updated":"2018-10-08T03:26:35.140Z","comments":true,"path":"Dive-into-FE-router.html","link":"","permalink":"http://hi.thisisray.me/Dive-into-FE-router.html","excerpt":"","text":"","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"FE-router","slug":"FE-router","permalink":"http://hi.thisisray.me/tags/FE-router/"}]},{"title":"AngularJS: Service、Factory、Provider","slug":"AngularJS-Service、Factory、Providers","date":"2018-04-24T00:49:12.000Z","updated":"2018-10-08T03:26:35.139Z","comments":true,"path":"AngularJS-Service、Factory、Providers.html","link":"","permalink":"http://hi.thisisray.me/AngularJS-Service、Factory、Providers.html","excerpt":"最近在接触 AngularJS， 被晦涩难懂的各种概念搞得头疼脑涨。Service、Factory、Provider 就是其中几个。","text":"最近在接触 AngularJS， 被晦涩难懂的各种概念搞得头疼脑涨。Service、Factory、Provider 就是其中几个。 FactorySyntax: module.factory(&#39;factoryName&#39;, function) Result: the value that is returned by invoking the function reference passed to module.factory source code: return factoryName = fn() Note Must return an object which is the main difference differentiates it with other design patterns. We can expose any functionality to where it be injected. ServicesSyntax: module.service(&#39;serviceName&#39;, function) Result: we will be provided with an instance of the function. In other words new FunctionYouPassedToService() source code: return serviceName = new fn() Note: Don’t need to return any object when create a AngularJS service for it can be instantiated by Angular self. All we need to do is just add the functionality to this variable. ProviderSyntax: module.provider(&#39;providerName&#39;, function) Result: we will be provided with (new ProviderFunction()).$get() source code: return providerName = (new fn()).$get() Note 1. Provider is one of which can be configured (another is constant) during the module configuration phase Expose any more functionality through provider add it under $get like:12345678this.$get: function() &#123; return &#123; name: _name, getName: function() &#123; return name &#125; &#125;&#125; Additional When an AngularJS app is started, it has a certain “boot-order” (I think it same to life-cycle ?_?). From the perspective of a developer, it looks like this: 1234567anuglar.module('myModule', []) .config(function(injectables) &#123; // providers &amp; constants &#125;) .run(function(injectables) &#123; // do initialization &#125;) referenceAngularJS: Service vs Factory vs Providers made super simple – Ng-ninja AngularJS: Service vs provider vs factory – Stack Overflow AdditionalConstantA constant can not be intercepted by a decorator, that means that the value of a constant should never be changed (though it is still possible to change it programmatically in Angular 1.x). ValueA value is nothing more than a simple injectable value. The value can be a string, number but also a function. Value differs from constant in that value can not be injected into configurations, but it can be intercepted by decorators. DecoratorA decorator can modify or encapsulate other providers. There is one exception and that a constant cannot be decorated. ##Summary All the providers are instantiated only once. That means that they are all singletons.All the providers except constant can be decorated. A constant is a value that can be injected everywhere. The value of a constant can never be changed. A value is just a simple injectable value. A service is an injectable constructor. A factory is an injectable function. A decorator can modify or encapsulate other providers except a constant. A provider is a configurable factory.","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://hi.thisisray.me/tags/AngularJS/"}]},{"title":"数组和它的方法们","slug":"数组和它的方法们","date":"2018-03-11T06:22:00.000Z","updated":"2018-10-08T03:26:35.144Z","comments":true,"path":"数组和它的方法们.html","link":"","permalink":"http://hi.thisisray.me/数组和它的方法们.html","excerpt":"认识一下数组和它的朋友们","text":"认识一下数组和它的朋友们 全家福总体上可将方法分为两大类： 改变原数组（mutator methods） 和 不变原数组（accessor methods） Mutator methods copyWithin: 复制指定位置的元素到指定位置，返回修改过后的数组 fill 用指定元素替换指定位置元素, 返回修改过后的数组 pop 移除最后一个元素，并返回它 push 数组尾部追加新元素，返回修改过后的数组 reverse 反转数组，返回修改过后的数组 shift 移除头部第一个元素，并返回它 sort 默认按照 Unicode code points 对数组排序，并返回 splice 从制定位置移除/增加指定位数的元素 unshift 在头部添加指定元素 Accessor methods concat 合并两个数组 includes 判断数组是否含有指定元素，返回 ture / false indexof 返回指定元素的索引 join 将数组/类数组（具有 length 属性）拼接为字符串并返回 lastindexof 返回指定元素最后一次出现的索引 slice 挑选出指定 起始-结束 的数组元素，返回由其组成的新数组 toSource (非标准) tostring tolocalestring 如何记忆 push pop shift unshift个人总是记不住这四个方法的对应关系，直到看了 JS 高级编程指南将它们又细分为 栈方法 队列方法 栈方法 模仿栈的行为 LIFO(Last In Firest Out) push() + pop() 实现 队列方法 模仿栈的行 FIFO(First In First Out) shift() + push() 正向操作队列 unshift() + pop() 反向操作队列 \b利用数组实现队列123456789101112131415161718192021222324252627282930313233343536373839404142434445function Queue() &#123; this.que = new Array();&#125;Queue.prototype = &#123; // 尾部插入元素 enqueue: function(ele) &#123; this.que.push(ele); &#125;, // 头部取出元素 dequeue: function() &#123; if (!this.que.empty()) this.que.shift(); &#125;, // 判断队列是否为空 empty: function() &#123; if (this.length === 0) return true; else return false; &#125;, // 查看队首元素 front: function() &#123; if (!this.que.empty()) return this.que[0]; &#125;, // 查看队尾元素 back: function() &#123; if (!this.que.empty()) return this.que[length - 1]; &#125;, // 查看所有元素 toString: function() &#123; return this.que.join(' '); &#125;, // 清空队列 clear: function() &#123; this.que.length = 0; &#125;&#125;var a = new Queue();a.enqueue(1)","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"面试中遇到的问题","slug":"面试中遇到的问题","date":"2018-03-11T06:12:31.000Z","updated":"2018-10-08T03:26:35.146Z","comments":true,"path":"面试中遇到的问题.html","link":"","permalink":"http://hi.thisisray.me/面试中遇到的问题.html","excerpt":"收集一些面试中的问题，变得更强。","text":"收集一些面试中的问题，变得更强。 数组都有哪些方法？篇幅有点长， 单开一篇文章。 ➡️ 数组和它的方法们 官方文档 文中另提到利用数组模拟队列 数组处理 将字符串改写为驼峰\b命名方式。例如： 输入 &#39;get_user_by_id&#39;, 输出 \bgetUserById 1234567891011121314function transfor (str) &#123; var arr = str.split('_'), // 将原始字符串分割成数组 [get, user, by, id] sec_arr = []; // 用来缓存遍历上述数组的每一个元素 =&gt; [g，e，t] [u，s，e，r] [b，y] [i，d] for (var i = 1 ;i &lt; arr.length; i++) &#123; sec_arr = arr[i].split(''); // 更新为当前遍历到的元素 sec_arr[0] = sec_arr[0].toUpperCase(); // 对首字母进行大写处理并覆盖原值 arr[i] = sec_arr.join(''); // 将得到的\b新值重新拼成字符串复制给\b大元素，进入下一轮循环。 &#125; return arr.join(''); // 循环结束，将大元素\b数组拼成数组返回 &#125; console.log(transfor('get_user_by_id')); 数组去重 12345678910// 遍历数组，判断当前元素是否存在于 final 数组，没有则保留function unique1(arr) &#123; var final = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (final.indexOf(arr[i]) == -1) &#123; final.push(arr[i]); &#125; &#125; return final;&#125; 12345678910// 遍历当前数组元素，如果当前元素第一次出现的位置 == 当前索引，则保留function unique2(arr) &#123; var final = []; for(var i = 0; i &lt; arr.length; i++) &#123; if (arr.indexOf(arr[i]) == i) final.push(arr[i]); &#125; return final;&#125; 123456789101112131415// 先排序，将原数组的第一元素放入 final 数组中作为起始的比较 （以防下面的循环判断第一次\b出现错误影响执行）。// 以 final 数组当前的最后\b一项作为比较\b基础，若循环到的与\b final 最后一项不等则\b保留。function unique3(arr) &#123; arr.sort(); var final = [arr[0]]; for(var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== final[final.length - 1]) &#123; final.push(arr[i]); &#125; &#125; return final; &#125; 生成指定范围的 10 个不重复随机数，并排序。 12","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"job interview","slug":"job-interview","permalink":"http://hi.thisisray.me/tags/job-interview/"}]},{"title":"浏览器渲染及优化","slug":"浏览器渲染及优化","date":"2018-03-06T00:41:22.000Z","updated":"2018-10-08T03:26:35.145Z","comments":true,"path":"浏览器渲染及优化.html","link":"","permalink":"http://hi.thisisray.me/浏览器渲染及优化.html","excerpt":"如何才能提高渲染速度？","text":"如何才能提高渲染速度？ 常用措施 将频繁重绘回流元素单独作为一个图层，这样就每次只重排重绘单一图层也能提高性能。 修改css新建图层有两种办法： will-change：transform transform：translateZ(0) - 参考浏览器前端优化 - 众诚翻译 浏览器渲染过程及性能优化","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://hi.thisisray.me/tags/性能优化/"}]},{"title":"reflow（重排） 和 repaint（重绘）","slug":"reflow（重排）-和-repaint（重绘）","date":"2018-03-02T00:45:21.000Z","updated":"2018-10-08T03:26:35.143Z","comments":true,"path":"reflow（重排）-和-repaint（重绘）.html","link":"","permalink":"http://hi.thisisray.me/reflow（重排）-和-repaint（重绘）.html","excerpt":"什么是重绘与重排，如何减少？","text":"什么是重绘与重排，如何减少？ 是什么reflow： 浏览器重新渲染部分或全部文档，重新计算元素位置和几何解构。页面\b至少发生一次重排在页面初次加载的时候。 \brepaint： 只\b改样式而不影响布局，如改： \bbackground-color 等。 触发条件reflow \b盒模型相关： width height margin padding border … 定位、浮动： float position … 文字解构： text-align line-height overflow font-size … 调整窗口大小 样式表变动 元素内容变化，尤其是输入控件 dom操作 css伪类激活 计算元素的offsetWidth、offsetHeight、clientWidth、clientHeight、width、height、scrollTop、scrollHeight repaint 元素更新样式风格相关的属性时。 注 ⚠️：\u001creflow 一定会 repaint，repaint 不一定会 reflow 如何避免避免 reflow 本质上是减少对 render tree 的操作，\brender tree 包括 DOM 和 CSSOM 的信息。当二者都组建完毕时才进行 render tree 的合并。中途一旦遇到\b脚本文件就会\b停止\b组建，若涉及到对节点或样式的修改会等待修改完毕再继续组建。（这是发生在第一次加载的时候，后续的改变就是\b\b描述的那样\b重排的情况了） 直接改类名,减少分别\b修改样式的次数 1234567// 不好的写法 var left = 1; var top = 2; ele.style.left = left + \"px\"; ele.style.top = top + \"px\"; // 比较好的写法 ele.className += \" className1\"; 或者将几次修改内容拼接成一个字符串，一次性修改，其实原理同上。 123ele.style.cssText += \";left: \" + left + \"px;top: \" + top + \"px;\"; \b\b\b整体搬离，减少\b reflow 使用DocumentFragment进行缓存操作,引发一次回流和重绘； DocumentFragment 是 ‘a minimal document object that has no parent.A common use for DocumentFragment is to create one, assemble a DOM subtree within it, then append or insert the fragment into the DOM using Node interface methods such as appendChild() or insertBefore()). ’ 1234567891011document.addEventListener('DOMContentLoaded', function () &#123; var date = new Date(), fragment = document.createDocumentFragment();for (var i = 0; i &lt; 7000; i++) &#123; var tmpNode = document.createElement(\"div\"); tmpNode.innerHTML = \"test\" + i; fragment.appendChild(tmpNode);&#125; document.body.appendChild(fragment); console.log(\"speed time\", new Date() - date);&#125;); 使用display:none，只引发两次回流和重绘； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 频繁访问属性的时候，采取缓存。 123456789101112131415// 不好的写法for(let i = 0; i &lt; 20; i++ ) &#123; el.style.left = el.offsetLeft + 5 + \"px\"; el.style.top = el.offsetTop + 5 + \"px\";&#125;// 比较好的写法var left = el.offsetLeft,top = el.offsetTop,s = el.style;for (let i = 0; i &lt; 20; i++ ) &#123; left += 5; top += 5; s.left = left + \"px\"; s.top = top + \"px\";&#125; 替代会触发reflow和repaint的属性 比如用translate代替top，用opacity替代visibility 减少table的使用 动画实现的速度选择 对于动画新建图层 参考reflow和repaint引发的性能问题 CSS trigger","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://hi.thisisray.me/tags/HTML/"}]},{"title":"箭头函数中的 this","slug":"箭头函数中的-this","date":"2018-03-01T06:45:00.000Z","updated":"2018-10-08T03:26:35.145Z","comments":true,"path":"箭头函数中的-this.html","link":"","permalink":"http://hi.thisisray.me/箭头函数中的-this.html","excerpt":"箭头函数中的 this 是在定义的时候定义好的，如果当前作用域找不到 this 则向上查找直到找到为止。","text":"箭头函数中的 this 是在定义的时候定义好的，如果当前作用域找不到 this 则向上查找直到找到为止。 转自：箭头函数中this的用法.md 版权归原作者所有 es6中有一种新的定义函数的形式，称之为arrow function，即箭头函数。其带来了很多便捷性，本文不打算阐述arrow function带来的好处，而是想来说说它的this。 学习javascript的人，一般来说会遇到两道坎，其中一道是原型链，另一道可能就是this问题了。js的函数不断变化的this经常让人无法摸不着头脑，很多时候我们会使用bind、call、apply来强制指定函数的this。 本文假设你已经掌握了js中的this问题了，如果你不懂，可以访问如下链接，了解下js中的this问题 图解javascript this指向什么？ 词法作用域Arrow Function中的this机制和一般的函数是不一样的。本质来说Arrow Function并没有自己的this，它的this是派生而来的，根据“词法作用域”派生而来。 因此Arrow Function中的this是遵守“词法作用域”的 什么是词法作用域？ 一般来说，作用域有两种常见的模型，一种叫做词法作用域（Lexical Scope），一种叫做动态作用域（Dynamic Scope）。而javascript采取的便是词法作用域 简单来说，所谓的词法作用域就是一个变量的作用在定义的时候就已经被定义好，当在本作用域中找不到变量，就会一直向父作用域中查找，直到找到为止。 说到这一点，我相信大家都明白了，不明白？上个例子1234567891011function fn() &#123; var a = 'hello' var b = 'javascript' function innerFn() &#123; var b = 'world' console.log(`$&#123;a&#125; $&#123;b&#125;`) &#125; innerFn()&#125;fn() // hello world 因为在innerFn中已经定义了b所以，因此在查找b时便不会去使用父作用域中的b了。 Arrow Function中的this便遵循了这个含义 Arrow Function中的this先来看一个案例12345678910111213141516function taskA() &#123; this.name = 'hello' var fn = function() &#123; console.log(this) console.log(this.name) &#125; var arrow_fn = () =&gt; &#123; console.log(this) console.log(this.name) &#125; fn() arrow_fn()&#125;taskA() 最终我们会发现，两个内部函数的this都是window，而且this.name都是hello。 好像没什么区别。其实两个函数的this的产生流程是不一样的。 fn的this是在运行时产生的，由于我们是直接调用fn()，所以其this就是指向window。如果将其调用改成1234567891011121314function taskA() &#123; this.name = 'hello' var fn = function() &#123; console.log(this) console.log(this.name) &#125; var obj = &#123; name: 'haha', fn: fn &#125; obj.fn()&#125;taskA() 这时this就是obj对象，name是haha。这个符合我们对一般函数this的理解。 接下来看看Arrow Function中的this。它是怎么产生的呢，首先根据“词法作用域”，由于它本身没有this，于是便向上查找this，于是发现taskA是有this的，于是便直接继承了taskA的作用域。 那taskA的this又是什么？很简单，taskA是一个普通的函数，普通函数的this是在运行时决定的，由于我们是直接调用taskA的，即taskA()，所以其this便是window。 这下我们便明白了，arrow_fn中的this是window的原因了。我们稍微修改下案例123456789function taskA() &#123; var arrow_fn = () =&gt; &#123; console.log(this) console.log(this.name) &#125; arrow_fn()&#125;var obj = &#123;name: 'Jack'&#125;taskA.bind(obj)() 这时候，Arrow Function中的this便变成了obj对象了，name便是Jack。 可能有人会说，不是说Arrow Function中的this是定义的时候就决定了么，怎么现在又变成了运行的时候决定了呢。 Arrow Function中的this是定义的时候就决定的，这句话是对的。 该案例中，Arrow Function中，即arrow_fn的this便是taskA的this，在定义这个arrow_fn时候便决定了，于是又回到了上面说的，taskA是一个普通的函数，普通函数的this是在运行时决定的，而此时由于bind的原因，taskA的this已经变为obj，因此arrow_fnd的this便是obj了。 说到这里，相信大家应该已经明白了Arrow Function的this的含义和具体指向了。 所以我们才说Arrow Function的this是遵守“词法作用域”的。 其他案例我们再来看看其他案例1234567var obj = &#123; field: 'hello', getField: () =&gt; &#123; console.log(this.field) &#125;&#125;obj.getField() // undefined 这里最终会打出undefined，因为getField中的this就是window，而window是没有field这个属性的，所以就是undefined了。 所以我们一般不建议对象中定义函数的时候使用Arrow Function，毕竟this就会造成错误了。所以应该这么写123456var obj = &#123; field: 'hello', getField()&#123; console.log(this.field) &#125;&#125; 这样this就是obj了。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"CSS3 linear-gradient 全兼容","slug":"CSS3-linear-gradient-全兼容","date":"2018-02-28T03:03:02.000Z","updated":"2018-10-08T03:26:35.140Z","comments":true,"path":"CSS3-linear-gradient-全兼容.html","link":"","permalink":"http://hi.thisisray.me/CSS3-linear-gradient-全兼容.html","excerpt":"一次项目中遇到了 IE10 以上浏览器渐变失效的问题。以前在 CSS3 属性上遇到兼容问题就从网上找一段代码方式也不测试（懒）就过，这次测试人员测出来了问题，于是决定梳理一下。","text":"一次项目中遇到了 IE10 以上浏览器渐变失效的问题。以前在 CSS3 属性上遇到兼容问题就从网上找一段代码方式也不测试（懒）就过，这次测试人员测出来了问题，于是决定梳理一下。 兼容性 通过检测发现 linear-gradient 在 \bIE 上只有\b 10 以上支持，那我们在书写的过程中就要考虑到 8 以下该如何兼容。 synax123456/* 旧语法 */background: -prefix-linear-gradient(top, blue, white)/* 新语法 */background: -prefix-linear-gradient(to bottom, blue, white) 详细用法参考\b 深入理解CSS3 gradient斜向线性渐变 IE 10 以上完美支持新语法，其他浏览器\b同样支持。 \b新语法与旧语法的区别在于，新语法不需要再去写浏览器前缀，并且在第一个参数前加上了 to 来表示渐变结束方向，不同于旧语法的直接写开始方向。 新语法去前缀加 to 兼容 IE 6~8由于这些浏览器\b较古老无法支持新特性。但是在当时的环境下 IE 还是有自己的独门\b武器就是滤镜，这在当时超于同行的。 可以通过 IE 的上述滤镜功能来实现渐变效果，具体方法如下： 1filter: progid:DXImageTransform.Microsoft.Gradient(startcolorstr, endcolorstr, gradientType) 参数说明： startcolorstr: 渐变起始\b颜色 endcolorstr: 渐变结束颜色 gradientType: [0 | 1] 0 代表\b纵向渐变，\b1 代表\b横向渐变 IE9 以下同样不支持 opacity 和 rgba(),所以也就无法实现透明渐变，这个问题同样需要滤镜来实现了。 1filter:alpha(opacity=100 finishopacity=0 style=1 startx=0,starty=5,finishx=90,finishy=60) 其中各个参数的含义如下： opacity表示透明度，默认的范围是从0 到 100，他们其实是百分比的形式。也就是说，0代表完全透明，100代表完全不透明。 finishopacity 是一个可选参数，如果想要设置渐变的透明效果，就可以使用他们来指定结束时的透明度。范围也是0 到 100。 style用来指定透明区域的形状特征：0 代表统一形状 1 代表线形 2 代表放射状 3 代表矩形。 startx 渐变透明效果开始处的 X坐标。 starty 渐变透明效果开始处的 Y坐标。 finishx 渐变透明效果结束处的 X坐标。 finishy 渐变透明效果结束处的 Y坐标。 参考MDN 使用CSS渐变 CSS实现兼容性的渐变背景(gradient)效果","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://hi.thisisray.me/tags/CSS/"}]},{"title":"nginx 配置 HTTPS","slug":"nginx-配置-HTTPS","date":"2018-02-27T00:56:20.000Z","updated":"2018-10-08T03:26:35.143Z","comments":true,"path":"nginx-配置-HTTPS.html","link":"","permalink":"http://hi.thisisray.me/nginx-配置-HTTPS.html","excerpt":"最近听说谷歌浏览器打算将所有不是通过 HTTPS 协议访问的网站标记(为了全面推行HTTPS，谷歌让自己的Chrome变成了偏执狂)为不安全的消息后\b决定尝试将自己的博客\b转为 HTTPS。这就需要从头到尾的了解一下这究竟是个什么东西，能够实现什么，带来什么好处。下面这篇文章记录了整个过程。","text":"最近听说谷歌浏览器打算将所有不是通过 HTTPS 协议访问的网站标记(为了全面推行HTTPS，谷歌让自己的Chrome变成了偏执狂)为不安全的消息后\b决定尝试将自己的博客\b转为 HTTPS。这就需要从头到尾的了解一下这究竟是个什么东西，能够实现什么，带来什么好处。下面这篇文章记录了整个过程。 12345所用环境配置：主机：阿里云 CES 1核 1\bGB服务器： nginx操作系统： CentOS Linux release 7.4.1708 (Core) 什么是 HTTPS","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://hi.thisisray.me/tags/HTTP/"},{"name":"nginx","slug":"nginx","permalink":"http://hi.thisisray.me/tags/nginx/"}]},{"title":"原型与原型链","slug":"原型与原型链","date":"2018-02-23T02:36:29.000Z","updated":"2018-10-08T03:26:35.144Z","comments":true,"path":"原型与原型链.html","link":"","permalink":"http://hi.thisisray.me/原型与原型链.html","excerpt":"彻底搞清“原型与原型链”","text":"彻底搞清“原型与原型链” \bprototype 每个 函数 都有一个 prototype 属性，属性指向的是构造函数的原型。 原型： 每一个 \bJavascript 对象（除 null 外）在创建的时候就会与之关联另一个对象，这个对象就是原型。 __proto__每一个 Javascript 对象（除了 null）都具有这个属性， 指向该对象的原型。 1234567function Person() &#123;&#125;var person = new Person();person.__proto__ === Person.prototype; // true constructor这个属性只存在于原型之上，指向相关联的构造函数。例如 Person === Person.prototype.constructor。 \b 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止 原型与原型原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它。 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 原型对象就是通过 Object 构造函数生成的。 原型链1Object.prototype.__proto__ === null // true null 表示“没有对象”，即该处不应该有值。 由相互关联的原型组成的链状结构就是原型链 综上汇集成一张图表示 补充__proto__ 是每个对象都有的属性，它指向对象的原型。绝大部分浏览器都\b支持这个非标准的方法，\b但是它并不存在与原型之中，调用它的效果如同 Object.getPrototypeOf(obj)。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"Node.js","slug":"Node-js","date":"2018-02-22T13:13:02.000Z","updated":"2018-10-08T03:26:35.141Z","comments":true,"path":"Node-js.html","link":"","permalink":"http://hi.thisisray.me/Node-js.html","excerpt":"学学 Node.js","text":"学学 Node.js Node.js 优势在 高并发、I/O 密集型 场景有明显优势 高并发： 同一时间访问服务器。 I/O密集： 指的是文件操作、网络操作、数据库,相对的有CPU密集,CPU密集指的是逻辑处理运算、压缩、解压、加密、解密 Web主要场景就是接收客户端的请求读取静态资源和渲染界面,所以Node非常适合Web应用的开发","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://hi.thisisray.me/tags/Node-js/"}]},{"title":"《Javascript高级程序设计 》 （一） 引用类型","slug":"《Javascript高级程序设计-》-（一）-引用类型","date":"2018-02-14T03:16:49.000Z","updated":"2018-10-08T03:26:35.143Z","comments":true,"path":"《Javascript高级程序设计-》-（一）-引用类型.html","link":"","permalink":"http://hi.thisisray.me/《Javascript高级程序设计-》-（一）-引用类型.html","excerpt":"《Javascript 高级程序设计》 读书系列第一部：引用类型 （文章顺序不是按照书本章节顺序排列）","text":"《Javascript 高级程序设计》 读书系列第一部：引用类型 （文章顺序不是按照书本章节顺序排列） 对象是某个特定引用类型的实例。\b新对象是通过使用 new 操作符后跟一个构造函数来创建的。 构造函数本身就是一个函数，是出于创建新对象的目的而定义的。 var person = new Object(); new Object()\b\b 已经完成了对象的创建，\b\b创建出来的是 Object 引用类型的新实例。 Object 类型创建方式： new Oject() 123var person = new Object();person.name = \"ray\";person.age = 29; 对象字面量 1234var person = &#123; name: \"ray\", age: 29&#125; \b⚠️ 注：上述两种写法在构造函数都是 Object 的时候是不会出现问题的，但是以下情况则需要注意： 1234567891011121314151617181920// 构造函数function \bAaa() &#123;&#125;// 方式一Aaa.prototype.name = \"ray\";Aaa.prototype.age = 23;// 方式二Aaa.prototype = &#123; name: \"ray\", age: 23&#125;var a1 = new Aaa();console.log(a1.constructor)// \b方式一： Aaa() 方式二： Object（） 可见利用对象字面量的方式赋值会改写\b\b实例的构造函数指向。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"git clone 时遇到 Permission denied (publickey) 怎么办？","slug":"github-配置-SSH-Key","date":"2017-11-04T16:41:35.000Z","updated":"2018-10-08T03:26:35.142Z","comments":true,"path":"github-配置-SSH-Key.html","link":"","permalink":"http://hi.thisisray.me/github-配置-SSH-Key.html","excerpt":"如果在 git clone 时遇到 Permission denied (publickey) 怎么解决？","text":"如果在 git clone 时遇到 Permission denied (publickey) 怎么解决？ 这个问题的原因可能有多个，以下解决方法不能保证都能见效。先记录下来，回头研究透彻再补充。 问题带来的影响不能 clone repository。 解决步骤 First you’ll want to cd into your .ssh directory. Open up the terminal and run:1cd ~/.ssh &amp;&amp; ssh-keygen 复制 SSH Key 到剪贴板OS X: cat id_rsa.pub | pbcopyLinux: cat id_rsa.pub | xclipWindows: cat id_rsa.pub | clip 打开 github 个人主页， 点击头像， 选择 setting -&gt; SSH and GPG keys 点击 New SSH key 在 key 文本域中 Ctrl + v， title 文本域随便起一个自己能分辨的名称即可。 Done! 补充理解 2018-01-29 09:12 星期一 经过一些实践发现上述过程其实只是在本地生成 SSH密钥 并通过 github 网站提供的方法将本地密钥与 github 账户进行关联，这样用户自己就可以在 github 上创建仓库并通过 use SSH 的方式 clone 仓库代码到本地了。 上述的过程并不是问题的解决方式。因为上述问题出现在自己克隆别人仓库的项目时出现的。在这个克隆过程中选择了通过 use SSH 的方式导致了错误的出现。错误原因是仓库作者并没有将用户的 SSH 密钥 添加到自己的信任列表中，所以就不能 clone 项目代码。 解决方法： use HTTP 参考Git - Permission denied (publickey)","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"}]},{"title":"git 切换分支","slug":"git 切换分支","date":"2017-09-13T09:15:50.000Z","updated":"2018-10-08T03:26:35.142Z","comments":true,"path":"git 切换分支.html","link":"","permalink":"http://hi.thisisray.me/git 切换分支.html","excerpt":"当从远程仓库克隆\b出一个项目后， 默认显示项目的default branch（一般为 master）。而我们想要调适其他分支的代码就需要用到 \bgit 的切换分支命令了。","text":"当从远程仓库克隆\b出一个项目后， 默认显示项目的default branch（一般为 master）。而我们想要调适其他分支的代码就需要用到 \bgit 的切换分支命令了。 原理克隆完成后本地工作区的分支是指向 \bmaster 分支的，这时可以通过 git branch 命令查看分支情况。 * 代表当前所在分支 这里的输出结果说明本地代码目前只有一个 master 分支， 使用以下命令查看\b本地和远程所有的分支 图上\b展示的是本地共 1 个分支（master）和远程共 2 个分支（master、src），至于 HEAD 是什么请参考：HEAD 操作了解\b项目分支情况，我们就会明白如果想要在本地切换分支，就需要先建立一个与远程分支结构相对应的分支以存储代码。\b具体操作如下： \b git checkout -b &lt;新建本地分支名称&gt; &lt;远程主机名称/远程分支名&gt; 这里的git checkout -b 其实是两个命令的缩写形式（表示创建并切换到）。 具体是哪两条： git brach src 和 git checkout src 经过以上的操作\b之后，我们再查看一次所有的分支情况： 可以看到现在我们的本地和远程仓库的分支情况已经能够对应起来，之后就可以通过 git checkout &lt;分支名称&gt; 来自由的切换代码了。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"}]},{"title":"MacOS 下安装配置 jdk","slug":"MacOS-下安装配置-jdk","date":"2017-08-20T02:12:54.000Z","updated":"2018-10-08T03:26:35.141Z","comments":true,"path":"MacOS-下安装配置-jdk.html","link":"","permalink":"http://hi.thisisray.me/MacOS-下安装配置-jdk.html","excerpt":"os: macOS High Sierra version 10.13.3 jdk: 1.7.0_80","text":"os: macOS High Sierra version 10.13.3 jdk: 1.7.0_80 注： 1.6 版本以下的 jdk oracle 官网没有提供 macOS 版本的下载，如果需要这些版本的\b需要\b前往苹果官网进行下载。 点击下载 这里主要\b以 1.7 为例 获取并安装 jdkoracle Java Archive 集合下载 在上面的链接选择需要的\b版本进行下载，这里我选择 1.7 \b点击 Accept License Agreemen 而后点击下载链接进行下载 下载完成后，双击打开安装包，一路下一步到底。 \b\b打开终端，通过 java -version 命令查看是否安装成功 成功后如下图： 配置环境变量 首先定位到 /etc/profile 通过 sudo vi profile 对文件进行编辑，将1234JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home\"export JAVA_HOMECLASS_PATH=\"$JAVA_HOME/lib\"export PATH=\"$PATH:$JAVA_HOME\" 指定 source 命令，使修改生效 检验环境变量是否设置成功 echo $JAVA_HOME 2017-02-26 星期一 23:21 不知道是不是因为\b上述配置原因导致的项目无法启动，错误\b代码：12EVERE: Servlet.service() for servlet default threw exceptionjava.lang.ClassCastException: org.apache.catalina.util.ParameterMap cannot be cast to java.util.HashMap 错误原因还未能找到，但是\b因为这个原因接触到了 Mac 下如何卸载 java，方法如下 ⬇️ 卸载 \bjava 参考：官方卸载方法 java, 官方卸载方法 jdk 卸载 java Note: 需使用管理员权限 sudo 打开终端并输入一下命令分别运行 123sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -fr /Library/PreferencePanes/JavaControlPanel.prefPanesudo rm -fr ~/Library/Application\\ Support/Java 卸载 jdk Note: 需使用管理员权限 sudo 打开终端并定位到 /Library/Java/JavaVirtualMachines ,并且删除下方的 jdk 文件夹","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hi.thisisray.me/tags/java/"},{"name":"MacOS","slug":"MacOS","permalink":"http://hi.thisisray.me/tags/MacOS/"}]},{"title":"可能这辈子都记不住了","slug":"可能这辈子都记不住了","date":"2017-08-02T06:56:32.000Z","updated":"2018-10-08T03:26:35.144Z","comments":true,"path":"可能这辈子都记不住了.html","link":"","permalink":"http://hi.thisisray.me/可能这辈子都记不住了.html","excerpt":"一些琐碎记不住的东西","text":"一些琐碎记不住的东西 逗号运算符表达形式： 表达式1，表达式2 … 表达式n求解过程： 先计算表达式1，在计算表达式2，以此类推。最终的值为表达式n的值 12345678910var count = 0;console.log(typeof count === \"number\"); // true , 这个不用解释了console.log(!!typeof count === \"number\"); // false// 这里涉及到就是优先级和布尔值的问题// typeof count 就是字符串\"number\"// !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true// 最后才=== 比较 , true === \"number\" , return false 12x = 8*2,x*4// 先计算 8*2 再赋值给 x 最后计算表达式结果为 64 x最终值为 16 12(x=8*2,x*4),x*2// 先赋值 x=16 再逗号得64 ，最后外层逗号得整个表达式的值为32， x最终为16 12x=(z=5,5*2) /*整个表达式为赋值表达式，它的值为10，z的值为5*/x=z=5,5*2 /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/ 带命名空间的事件(namespaced events)on()事件的第一个参数是事件的类型，可以通过click.[name]的方式对事件加标识以方便后期移除特定事件。代码如下：12345678$('a').on('click', function() &#123; //Handler 1&#125;);$('a').on('click', function() &#123; //Handler 2&#125;);$('a').off('click') 会将两个移除 12345678$('a').on('click.namespace1', function() &#123; //Handler 1&#125;);$('a').on('click.namespace2', function() &#123; //Handler 2&#125;);$('a').off('click.namespace2'); 只移除名叫namespace2的点击事件 几个测试题12345[] == [] // fasle5 =='5' // true5 === '5' // fale5 / 0 // Infinity+new Date() // 123456if(!(\"a\" in window))&#123; var a = 10;&#125;console.log(a); // undefined// 这里是因为 \b\bvar a 变量声明提升，导致判断一直为 false 不进分支。所以结果为 undefined this12345678function Person() &#123; this.age = 0; // 指向实例化的对象 setInterval(function growup() &#123; this.age++; // 指向 window &#125;, 1000);&#125;var p = new Person(); typeof(null) === &#39;object&#39; 的原理不同对象在底层都为二进制，在 JS 中前三位都为 0 的话就会被判定为 object，null 的二进制都是 0。 Javascript 类型主类型(6): null, undefined, boolean, number, string, object object 子类型(9)：String, Number, Function, Boolean,Array, Date Object, RegExp, Error https 请求方式options, head, put, delete, get, get, post, trace, connect 阻止表单提交12345form.addEventListener(\"submit\", function(e) &#123; var event = event || window.event; event.preventDefault(); window.event.returnValue = false; // IE 6 ~ 8&#125;) jQuery实现： 123456789101112// 取消表单提交动作，防止事件冒泡$(form).on('submit', false);// 仅取消默认动作$(form).on('submit', function(event) &#123; event.preventDefault();&#125;)// 防止事件冒泡，但不禁止提交行为$(form).on('submit', function(event) &#123; event.stopPropagation();&#125;) 禁用 input 记忆性输入123IE: &lt;input type=\"text\" autocomplete = \"off\"&gt;Firefox: &lt;input type=\"text\" disableautocomplete=\"off\"&gt;若Firefox方式对chrome无效，则在 &lt;form&gt; 上统一设置 autocompelet = \"off\" jQuery 事件委托123$('body').on('click', 'div', function() &#123; console.log($(this).text());&#125;) 快速生成时间戳1var current = +new Date(); 跨 iframe 获取元素1$('子元素', '父元素') window.parent.document 包含当前窗口的父窗口 Document.readyState 文档加载状态value: loading/ 加载中 =&gt; document 仍在加载中 interactive / 互动 =&gt; document 已被加载和解析，但 image, CSS, Javascript 仍在加载中。 此阶段会触发 DomContentLoaded 事件 compete / 完成 =&gt; document 和所有子资源完成加载。 load 事件加载 readyState 属性值变化会触发 document.onreadyStateChange 事件 IE 下 document.documentElement.doScroll，是 IE 下特有的方法，检测 DOM 是否加载完成。 行内元素转块级元素position: absolute / fixed; 和 float 都可以使 行内元素转为块级元素 i++ 与 ++i 例：购物车修改数量 1shuliang = (++shuliang &gt; stock ? stock : shuliang) 取整与转换123456789101112var ac = '1.23423';/*** 字符串转数字*/+ac // 1.23423/*** 取整*/~~acac &gt;&gt; 0 判断奇偶123456789101112(222 &amp; 1) == 0 ? '偶数' : '奇数'/***取最近的偶数*/( 1111 | 1 ) // 1110/***除2取整*/~~(5/2)5 &gt;&gt; 1 强制 Webkit 内核渲染很多国产浏览器都是双内核，例如“360、QQ”等，它们都提供了强制使用 Webkit 内核渲染的开启模式 1&lt;meta name=\"renderer\" content=\"webkit\" /&gt; CSS 语法中表示参数符号类型以 linear-gradient() 举例 1background-image: linear-gradient( [ &lt;angle&gt; | &lt;side-or-corner&gt; ,]? &lt;color-stop&gt; [, &lt;color-stop&gt;]+ ); [] 在正则中表示一个字符类，这里，你可以理解为一个小单元。 | 表示候选。也就是“或者”的意思，要么前面的，要么就后面的。 ? 为量词，表示0个或1个，言外之意就是，你可以不指定方向，直接渐变色走起。例如：1background:linear-gradient(red, yellow); 就是从上往下的红黄条纹效果。 + 也是量词，表示1个或者更多个。因此，终止颜色是不可缺少的。例如：linear-gradient(red)是酱油命，白板。 &lt;&gt; 中的是关键字，主要是让开发人员知道这里应该放些什么内容。 CSS 选择器排序1.id选择器（#myid） 2.类选择器（.myclassname） 3.标签选择器（div,h1,p） 4.相邻选择器（h1+p） 5.子选择器（ul &lt; li） 6.后代选择器（li a） 7.通配符选择器（*） 8.属性选择器（a[rel=”external”]） 9.伪类选择（a:hover,li:nth-child） CSS 可继承 &amp; 不可继承属性不可继承 display：规定元素应该生成的框的类型 文本属性： vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 unicode-bidi：设置文本的方向 盒子模型的属性 width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 生成内容属性：content、counter-reset、counter-increment 轮廓样式属性：outline-style、outline-width、outline-color、outline 页面样式属性：size、page-break-before、page-break-after 声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 可继承属 字体系列属性 font：组合字体 font-family：规定元素的字体系列 font-weight：设置字体的粗细 font-size：设置字体的尺寸 font-style：定义字体的风格 font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。 font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。 font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。 文本系列属性 text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色 元素可见性：visibility 表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout 列表布局属性：list-style-type、list-style-image、list-style-position、list-style 生成内容属性：quotes 光标属性：cursor 页面样式属性：page、page-break-inside、windows、orphans 声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation 所有元素可以继承的属性 元素可见性：visibility 光标属性：cursor 内联元素可以继承的属性 字体系列属性 除text-indent、text-align之外的文本系列属性 块级元素可以继承的属性 text-indent、text-align 参考 头部高度固定，剩下自适应头部正常排列，下方 width: 100%;absolute: top: 100px; bottom: 0; 普通元素不设置宽度的时候改为绝对定位会丢失宽度 表单只有一个 input text 时W3C 标准中有如下规定： When there is only one single-line text input field in a form, the user agent should accept Enter in that field as a request to submit the form. 当 \bform 元素中只有一个输入框时， 在该输入框中按下回车应该提交表单。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[]},{"title":"git 实操","slug":"git 实操","date":"2017-08-02T00:29:13.000Z","updated":"2018-10-08T03:26:35.142Z","comments":true,"path":"git 实操.html","link":"","permalink":"http://hi.thisisray.me/git 实操.html","excerpt":"工作中一直用 svn ，用久了之后感觉还是存在一些说不出来的不方便。以前一直想要接触一下 git 但总是因为没有项目可以实践。直到有一天突然想到可以将博文托管到 github 上啊，这样不就拥有了项目并且可以实践了吗，于是也就有了下面这篇连载文章，不定期更新~","text":"工作中一直用 svn ，用久了之后感觉还是存在一些说不出来的不方便。以前一直想要接触一下 git 但总是因为没有项目可以实践。直到有一天突然想到可以将博文托管到 github 上啊，这样不就拥有了项目并且可以实践了吗，于是也就有了下面这篇连载文章，不定期更新~ 官方文档是个好东西，一定要利用起来准备要托管的文件可以是项目代码，也可以是文本、图片任何类型文件。我这里就是几篇博文（markdown 格式） 初始化一个 git 项目这里有两种方法： 在 github 上直接通过图形化界面引导新建一个 repository 通过 commd line 的方式在相应的项目文件夹下进行初始化。 第一种方式的具体过程如下： 打开 github 上的个人主页, 点击 New repository 按钮。按照指导建立新仓库。 最够使用 git clone 的方式克隆项目到本地 下面使用第二种方式： 纯命令行的方式，这种方式的思路其实和第一种是相反的。 第一种是通过可视化的方式在远程建立好代码仓库，再克隆到本地的时候就不需要再手动初始化了； 第二种方式则是先在本地初始化好 git 项目，然后后通过命令行的 git 指令 与远程的仓库进行链接，前提也还是要有一个空的仓库。 以前觉得图形化的方式很方便快捷，但是现在觉得纯命令行的方式使用起来更有成就感。 具体步骤如下： 进入需要存储项目的目录下，右键呼出 bash 命令行窗口。 1234git init 项目名e.g.git init blog-demo 使用 git add remote 与远程仓库链接 现在只是本地创建好了 git 项目，还需要和远程的仓库建立起链接才能将代码 push（推送） 到远程仓库。 注：这里有一个警告，当第一次建立链接后但还没有进行第一次 pull 操作前，如果对远程仓库链接进行了 git remote rename &lt;oldname&gt; &lt;newname&gt; 的重命名操作pull 的操作会出现 non-fast-forward 的错误。（暂无解决方案…） 使用 git remote -v 查看远程状态 通过以上的操作，已经建立起了本地和远程仓库的链接，为下面的文件互相推送构建了基础。 pull 拉取远程仓库到本地git pull origin master 上面新建的远程仓库只包含一个 README.md 文件，执行过这条指令过后本地仓库就与远程仓库状态同步。 相似的操作还有 git clone, git fetch, git merge 暂时不详细描述。相关参考 提交git 的提交和 svn 的提交差别很大，这是由他俩原理决定的。`（未完，后期补） 添加 .gitignore 文件 .gitignore 是告诉 git 哪些文件是忽略提交的。 相关阅读 1touch .gitignore // 创建文件 如果要忽略的文件在创建gitigonre 文件前已经checked in，需要运行一下命令移除。 $ git rm --cached README.md 注: 执行完成后，要定位到 .gitignore 文件所在路径进行 push 撤销修改git checkout -- file 丢弃工作区的修改，产生以下两种情况： 修改后还未被放到暂存区，撤销修改到和版本库一样的状态 修改后已经 add 到了暂存区，并且又做了修改。撤销为添加暂存区后的状态，然后使用 git reset HEAD &lt;filename&gt; 来撤销暂存区的修改。 以上都是本地还未 commit 的情况。如果已经 commit 但还未 push 到远程仓库，则需要使用 版本回退 change remote使用 https 方式 clone 下来的代码在每次 pull 或者 push 时都会要求输入用户名和密码。为了解决这个问题，我们需要将代码的远程仓库地址 remote 改为 SSH。 具体实现如下： https -&gt; SSH 1git remote set-url origin git@github.com:USERNAME/REPOSITORY.git SSH -&gt; https 1git remote set-url origin https://github.com/USERNAME/REPOSITORY.git git pull --rebase在本地进行了多次修改并且事先没有 git pull 就直接 git push 时会被阻止。这种情况下就需要先 git pull 之后才能继续。 reference [译] 何时 merge 与何时 rebase","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"}]},{"title":"浮点数精度丢失问题","slug":"浮点数精度丢失问题","date":"2017-08-02T00:29:13.000Z","updated":"2018-10-08T03:26:35.145Z","comments":true,"path":"浮点数精度丢失问题.html","link":"","permalink":"http://hi.thisisray.me/浮点数精度丢失问题.html","excerpt":"前些天在项目中遇到一个离奇的问题&quot;1.38 * 10000 结果竟然是 13799.999999999998&quot; 使出浑身解数后上网搜索了一下，发现大多人说这是 JS 自身的一个 bug。拷贝了一段代码顺利解决问题，但是腾出时间后仔细了解发现问题远不是想象的那样简单。","text":"前些天在项目中遇到一个离奇的问题&quot;1.38 * 10000 结果竟然是 13799.999999999998&quot; 使出浑身解数后上网搜索了一下，发现大多人说这是 JS 自身的一个 bug。拷贝了一段代码顺利解决问题，但是腾出时间后仔细了解发现问题远不是想象的那样简单。 &emsp;&emsp;问题的根本原因归结于 JavaScript 采用IEEE-754 的标准存储数据，而且 JavaScript 只有 Number 一种数字类型，不像其他语言一样有 int、float、decimal 等。所以这就造成了一系列的知名问题0.1+0.2 != 0.3 0.100000000000000002 == 0.1 //true。 &emsp;&emsp;众所周知，计算机采用二进制运算，所以不论是什么类型的数据计算机都会将其转化为二进制进行运算。JavaScript 中所有的 Number 都是以64-bit的双精度浮点数存储的，具体如何存储见下图： &emsp;&emsp;具体的存储原理目前还没有完全弄清楚，在此不做赘述。 &emsp;&emsp;大致的原理：双精度浮点数将此64位划分为3段，这3段（64bit）确定一个浮点数的值，IEEE-754 的划分模式为 “1-11-52”，具体描述： 第1位（最左位）表示符号位，0代表正，1代表负 中间11位标识二进制科学计数法的指数部分 最后52位表示尾数部分，也就是有效域部分 &emsp;&amp;emsp综上可知，指数和尾数域是有限的，11位和52位 &emsp;&amp;emsp有了以上基础，问题的答案初步浮现出来 精度丢失在哪里 &emsp;&emsp;在十进制转化为二进制的时候。例如0.1+0.2在开始运算前要将两个数字分别转化为二进制，二者转化后都是无线新循环的。这就超出了 IEE-754规定的52位有效域。这种情况下就要采取规则制定的“舍入规则”，默认的是舍入最接近的值，如果“舍”和“入”一样接近，那么取结果为偶数的选择。 &emsp;&emsp;浮点计算的时候有一步叫对阶，以加法为例，要把小的指数域转化为大的指数域，也就是左移小指数浮点数的小数点，一旦小数点左移，必然会把52位有效域的最右边的位给挤出去，这个时候挤出去的部分也会发生“舍入”。这就又会发生一次精度丢失。 注意：精度丢失的叠加不一定会使结果偏差越来越大 console.log(0.1) 并不是 0.1&emsp;&emsp;打印的过程其实也是发生了二进制转十进制再转为字符串的过程，所以最后打印出来的并不是对浮点数的精确反应。 &emsp;&emsp;所有数值的计算和比较，都是这样以64bit的形式进行的，如果超出位数计算会发行精度丢失；比对会反常，即使是我们明显看出等或者不等的时候。例如1230.100000000000000002 == 0.1 //true0.100000000000000002 == 0.100000000000000010 // true 例外：+0==-0 解决方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var calc = &#123; add: function(a,b) &#123; var c,d,e; try &#123; c = a.toString().split(\".\")[1].length; &#125; catch (f) &#123; c = 0; &#125; try &#123; d = b.toString().split(\".\")[1].length; &#125; catch (f) &#123; d = 0; &#125; return e = Math.pow(10,Math.max(c,d)),(this.mul(a,e) + this.mul(b,e)) / e; return c; &#125;, sub: function(a,b) &#123; var c,d,e; try &#123; c = a.toString().split(\".\")[1].length; &#125; catch (f) &#123; c = 0; &#125; try &#123; d = b.toString().split(\".\")[1].length; &#125; catch (f) &#123; d = 0; &#125; return e = Math.pow(10,Math.max(c,d)),(this.mul(a,e) - this.mul(b,e)) / e; &#125;, mul: function(a,b) &#123; var c = 0, d = a.toString(), e = b.toString(); try &#123; c +=d.split(\".\")[1].length; &#125; catch (f) &#123;&#125; try &#123; c += e.split(\".\")[1].length; &#125; catch (f) &#123;&#125; return Number(d.replace(\".\",\"\")) * Number(e.replace(\".\",\"\")) / Math.pow(10,c); &#125;, div: function(a, b) &#123; var c, d, e = 0, f = 0; try &#123; e = a.toString().split(\".\")[1].length; &#125; catch (g) &#123;&#125; try &#123; f = b.toString().split(\".\")[1].length; &#125; catch (g) &#123;&#125; return c = Number(a.toString().replace(\".\", \"\")), d = Number(b.toString().replace(\".\", \"\")), mul(c / d, Math.pow(10, f - e)); &#125;&#125; 感谢该死的IEEE-754浮点数，说「约」就「约」，你的底线呢？以JS的名义来好好查查你","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"JS 的非数字下标数组","slug":"js-的非数字下标","date":"2017-07-11T06:11:00.000Z","updated":"2018-10-08T03:26:35.142Z","comments":true,"path":"js-的非数字下标.html","link":"","permalink":"http://hi.thisisray.me/js-的非数字下标.html","excerpt":"Javascript 的数组虽然能够通过非数字下标获取数组元素，但是本质上它和 PHP 等语言的关联数组（数组下表不是数字而是字符串）并不一样。详细原理和特殊表现详见下文。","text":"Javascript 的数组虽然能够通过非数字下标获取数组元素，但是本质上它和 PHP 等语言的关联数组（数组下表不是数字而是字符串）并不一样。详细原理和特殊表现详见下文。 “正常人思路”1234var array = [] ;array[\"a\"] = \"hello\";array[\"b\"] = \"world\" ;console.log(\"length:\"+array.length); 正常思路认为结果输出应该为 length:2。 “非正常输出”但灵活的 Javascript 在上述问题有着别样的处理方法，实际的输出结果为 length:0。这是为什么？ 我们将代码稍作改动,再看结果。12345var array = [] ;array[\"a\"] = \"hello\";array[\"b\"] = \"world\" ;array[\"10\"] = \"!\";console.log(\"length:\"+array.length); 事情的真相Javascript 数组的下标存在一个范围值（0~2^32）。对于给定的下标值不在此范围内，JavaScript 就会将下标值转化为字符串，并将该字符串对应的值作为数组的该数组对象的属性值而不是数组的元素。例如array[-1]就是给array对象添加了一个名为“-1”的属性值。 如果下标值在有效范围，不论值得类型是数字还是字符串，JavaScript 都会强制转化为数字。array[100]如果前方之前没有值，JavaScript 会自动填充，并且数组的length为100。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"《图解 HTTP》 （三） HTTP 报文内的 HTTP 信息","slug":"《图解-HTTP》-（三）-HTTP-报文内的-HTTP-信息","date":"2017-06-02T13:24:00.000Z","updated":"2018-10-08T03:26:35.143Z","comments":true,"path":"《图解-HTTP》-（三）-HTTP-报文内的-HTTP-信息.html","link":"","permalink":"http://hi.thisisray.me/《图解-HTTP》-（三）-HTTP-报文内的-HTTP-信息.html","excerpt":"本系列是阅读 《图解 HTTP》 时的阅读笔记。","text":"本系列是阅读 《图解 HTTP》 时的阅读笔记。 3.1 HTTP 报文 用于 HTTP 协议交互的信息被称为 HTTP 报文； 请求端叫 请求报文， 响应端叫 响应报文； HTTP 本身是由多行 （用 CR + LR 作换行符） 数据构成的字符串文本。报文首部 和 报文主体 由最初出现的空行（ CR + LF ） 划分。通常，并不一定由报文主体。 ( CR Carriage Return, 回车符：16进制 0x0d ) ( LF Line Feed, 换行符： 16进制 0x0a ) 3.2 请求报文及响应报文的结构请求行 / 响应行 状态行 （响应报文才有） 首部字段 表示请求和响应的各种条件和属性的各类首部，一般有 通用首部、请求首部、响应首部、实体首部 其他 HTTP 的 RFC 里未定义的首部 （ Cookie 等 ） 3.3 编码传输HTTP 传输数据可按原样传输，也可以编码传输提高效率。 注： 编码需由计算机完成， 因此会消耗更多 CPU 资源。 3.3.1 报文主体与实体主体的差异 ？？？ 报文（message）： HTTP 通信基本单位， 8 位字节流组成。 实体（entity）： 请求或响应的有效载荷数据，内容由实体首部和实体主体自称。 通常，报文主体等于实体主体。 当传输中进行编码时，实体主体内容变化才导致和报文主体产生差异。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://hi.thisisray.me/tags/HTTP/"}]},{"title":"解决 Enter passphrase key 问题","slug":"解决-Enter-passphrase-key-问题","date":"2017-05-20T14:46:48.000Z","updated":"2018-10-08T03:26:35.145Z","comments":true,"path":"解决-Enter-passphrase-key-问题.html","link":"","permalink":"http://hi.thisisray.me/解决-Enter-passphrase-key-问题.html","excerpt":"在本地生成 id_rsa 的时候对其设定了 passphrase ,以至于后来每次向 github 仓库 push 的时候都要手动输入一次 passphrase 才验证身份，这样虽然保证了安全性，但是大大降低了便捷性。所以就去搜寻了解决方案。","text":"在本地生成 id_rsa 的时候对其设定了 passphrase ,以至于后来每次向 github 仓库 push 的时候都要手动输入一次 passphrase 才验证身份，这样虽然保证了安全性，但是大大降低了便捷性。所以就去搜寻了解决方案。 解决方法本地依次运行以下代码： 12eval `ssh-agent`ssh-add ssh-agent 是用于管理密钥，ssh-add 用于将密钥加入到 ssh-agent 中，SSH 可以和 ssh-agent 通信获取密钥，这样就不需要用户手工输入密码了。 将以上命令写入到 ~/.bash_profile 中，可以免去每次重启会话都要重新输入上述两条命令的麻烦。 如上的命令\b只对当前会话有效，当会话关闭立马就会失效。 永久性解决问题利用 Keychain Add Identity Using Keychain to persist the passphrase through restarts by storing it in your keychain, you can use the -K option when adding the identity like this:ssh-add -K ~/.ssh/id_rsaOnce again, this will ask you for the passphrase, enter it and this time it will never ask again for this identity. 第一点中提到的解决方法就是没有利用 keychain 来管理密码。持久性只能保持到当前会话。 参考文章SSH Key - Still asking for password and passphrase","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://hi.thisisray.me/tags/ssh/"}]},{"title":"Mac 下安装 eclipse Java EE 奇怪问题的解决方法","slug":"Mac-下安装-eclipse-Java-EE-奇怪问题的解决方法","date":"2017-05-20T09:42:04.000Z","updated":"2018-10-08T03:26:35.141Z","comments":true,"path":"Mac-下安装-eclipse-Java-EE-奇怪问题的解决方法.html","link":"","permalink":"http://hi.thisisray.me/Mac-下安装-eclipse-Java-EE-奇怪问题的解决方法.html","excerpt":"Mac 下在安装 eclipse 时遇到的一个奇怪的问题，然而它的解决方法更加奇怪。","text":"Mac 下在安装 eclipse 时遇到的一个奇怪的问题，然而它的解决方法更加奇怪。 问题描述 搜寻过程第一开始以为是先前安装的 jdk 版本不对，因为 相应版本的 eclipse 对应相应的 jdk 版本。如果二者对应不上就会出现打不开的现象。 但是思来想去这个问题觉得原因应该不在于此，于是开始百度。百度错误代码，错误描述什么的都未果，直到无意间找到了知乎的一个问题，看描述和我遇到的基本一致，再看下方的回答表示问题都解决了。于是尝试通过解答是这解决一下自己的问题。具体方法如下，问题链接 总结问题的解决方法\b如同它本身一样令人匪夷所思，只需要将解压出来的 Eclipse.app 文件 拖到，记得一定是拖到，不能复制到桌面。然后再拖拽回\b解压出来的文件夹里，这样问题就解决了……","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hi.thisisray.me/tags/java/"},{"name":"MacOS","slug":"MacOS","permalink":"http://hi.thisisray.me/tags/MacOS/"}]},{"title":"MacBook 下npm install 'Please try running this command again as root/Administrator.'","slug":"MacBook-下npm-install-Please-try-running-this-command-again-as-root-Administrator","date":"2017-05-13T11:00:40.000Z","updated":"2018-10-08T03:26:35.141Z","comments":true,"path":"MacBook-下npm-install-Please-try-running-this-command-again-as-root-Administrator.html","link":"","permalink":"http://hi.thisisray.me/MacBook-下npm-install-Please-try-running-this-command-again-as-root-Administrator.html","excerpt":"刚入手的 Macbook Pro 2017 配置环境遇到的第一个问题就是 Please try running this command again as root/Administrator. 起初一看第一反应就是权限问题，加 sudo。但出于是第一次用 Mac 觉得还是上网搜索一下为好，得到结果后想幸好搜索了一下，问题果然不是那么简单。","text":"刚入手的 Macbook Pro 2017 配置环境遇到的第一个问题就是 Please try running this command again as root/Administrator. 起初一看第一反应就是权限问题，加 sudo。但出于是第一次用 Mac 觉得还是上网搜索一下为好，得到结果后想幸好搜索了一下，问题果然不是那么简单。 开篇先吐槽一下百度，搜出来的结果不仅质量差，而且这些低质量的解答还在互相复制，可悲啊。最终决定去外面搜寻答案。 果真已经有过人遇到这个问题，这也是我最终选择的解决方案。 链接如下：error installing coffeescript on mac 10.7.2 \b问题的原因确实是权限问题，但是\b通常用的解决方法也就是直接加 sudo 是\b不推荐的。 $USER 替换为个人计算机的用户名。 不推荐的原因： The npm author recommends not using sudo because packages can run arbitrary commands so sudo npm install is dangerous. He suggests switching the ownership of /usr/local to your user. 参考文章： npm install -g — ERR! Please try running this command again as root/Administrator.","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hi.thisisray.me/tags/git/"}]},{"title":"利用 @font-face 字体图标代替传统图标图片","slug":"利用 @font-face 字体图标代替传统图标图片","date":"2017-05-02T00:29:13.000Z","updated":"2018-10-08T03:26:35.144Z","comments":true,"path":"利用 @font-face 字体图标代替传统图标图片.html","link":"","permalink":"http://hi.thisisray.me/利用 @font-face 字体图标代替传统图标图片.html","excerpt":"项目中经常用到一些细小的图标，常见的方法是让美工做成 sprite 图。业务用到的时候通过设置元素背景图，再使用 background-position 属性一点点地变化到相应位置达到显示效果。这种方法一旦遇到图标聚集的地方并且还有 hover 效果的时候内心可以说是相当崩溃的。","text":"项目中经常用到一些细小的图标，常见的方法是让美工做成 sprite 图。业务用到的时候通过设置元素背景图，再使用 background-position 属性一点点地变化到相应位置达到显示效果。这种方法一旦遇到图标聚集的地方并且还有 hover 效果的时候内心可以说是相当崩溃的。 @font-face 登台一言以蔽之，这个 CSS 属性可以让你像操作文本一样操作图标，故而得名字体图标（图标字体）。 这么好用的属性看一看兼容性 IE6 都能兼容到，虽然是只兼容 EOT 格式，但是已经够用，为什么呢？ 因为下面这个平台。 IconFont - 阿里巴巴矢量图标库先上几张图，他是长这样的： 通过上面的方法，已经能够减少我们很大的工作量了。以前只能使用 img 的形式现在完全可以将选中的图标下载为 svg 格式的文件然后在浏览器中打开，最后将代码复制到项目中去。 这对于图标不多的地方已经相当实用了，但这还不是这个平台最厉害的地方，最厉害的在下面。 @font-face 的具体使用方法官方文档 123456789101112131415/* @font-face 属性要单独放在外面 */@font-face &#123; font-family: 'iconfont'; src: url('//at.alicdn.com/t/font_484185_rucmsm61ix5vobt9.eot'); src: url('//at.alicdn.com/t/font_484185_rucmsm61ix5vobt9.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_484185_rucmsm61ix5vobt9.woff') format('woff'), url('//at.alicdn.com/t/font_484185_rucmsm61ix5vobt9.ttf') format('truetype'), url('//at.alicdn.com/t/font_484185_rucmsm61ix5vobt9.svg#iconfont') format('svg');&#125;/* 使用的时候创建一个类，用 `font-family` 属性去引用 `@font-faily` 属性指定的 `font-family` 值，这样同时针对性的调整 `font-size` 等文本属性了 */.font-icon &#123; font-family: 'iconfont';&#125; 注意: Web fonts are subject to the same domain restriction (font files must be on the same domain as the page using them), unless HTTP access controls are used to relax this restriction. Web 字体受限于同源策略（字体文件必须和页面在相同的域之下），除非设置了 CORS 来放宽限制。 如果是使用这个平台的代码，我们抓包会看到返回的 response header 是下面这个样子的： 总结 @font-face 不论从兼容性和方便性来看，都大大超越了传统图片图标的形式，可以放心大胆地在项目中使用了。更多的使用技巧等待着去挖掘。 相关引用 HTTP CORS 阿里巴巴 iconfont @font-face","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://hi.thisisray.me/tags/CSS/"}]},{"title":"JS 库函数传入 undefined 参数的意图和作用","slug":"JS-库函数传入-undefined-参数的意图和作用","date":"2017-04-13T05:29:30.000Z","updated":"2018-10-08T03:26:35.140Z","comments":true,"path":"JS-库函数传入-undefined-参数的意图和作用.html","link":"","permalink":"http://hi.thisisray.me/JS-库函数传入-undefined-参数的意图和作用.html","excerpt":"&emsp;&emsp;最近了解 ES6 的箭头函数时无意间扯出了一连串的问题。首先碰到了 bind() 函数，先前只了解call() 和 apply() 不曾注意到 bind(),于是视线暂时转移到 bind()。&emsp;&emsp;当搜索 MDN 时发现 bind() 根据参数个数的不同分为不同的功能，其中手册中的例子在演示传入两个参数时第一个参数传入 undefined 这让我想起来了在 jQuery 框架中也曾经见到这样的做法但一直懒惰不去仔细了解，于是这个问题链的终点就停在此，我将以“递归”的方式从前往后发现问题，从后往前解决问题。","text":"&emsp;&emsp;最近了解 ES6 的箭头函数时无意间扯出了一连串的问题。首先碰到了 bind() 函数，先前只了解call() 和 apply() 不曾注意到 bind(),于是视线暂时转移到 bind()。&emsp;&emsp;当搜索 MDN 时发现 bind() 根据参数个数的不同分为不同的功能，其中手册中的例子在演示传入两个参数时第一个参数传入 undefined 这让我想起来了在 jQuery 框架中也曾经见到这样的做法但一直懒惰不去仔细了解，于是这个问题链的终点就停在此，我将以“递归”的方式从前往后发现问题，从后往前解决问题。 jQuery 为什么将 undefined 当作参数传入？ &emsp;&emsp;防止 window.undefined 被重写，由于 undefined 不是 JS 的保留字，所以存在开发者在全局作用域声明一个名为 undefined 的变量并赋值的情况。当开发者自己编写的函数内部用到了 window.undefined 在寻找时追溯到顶层作用域而此时发现已被重写，就会导致意外发生。值得注意的是这个问题只存在于一些老的浏览器，当时的规则 undefined 是可以被重写的。而当 ES 5 出台后规定全局作用域中的 window.undefined 是不能被写的，而函数作用域的依旧可以。 jQuery 为了兼容旧浏览器的做法 123(function(window,undefined)&#123; // xxx&#125;)(window) 这种解决方案的关键点在于设定 undefined 形参，但不传入对应的实参。这样可以保证将 window.undefined 传入函数内部。。这里有个知识点：JS 中缺省的参数，默认传递 undefined。当函数内部需要用到 undefined 时会先在内部作用域查找，而此时 undefined 已被传递进来并且是被赋为 window.undefined ，所以就停止了向上查找，排除了 window.undefined 被重写造成的影响。这种情况只存在于老旧浏览器, window.undefined 可被重写的 bug 。随着时间的发展，这种写法已不再使用，因为没有必要再兼容老旧浏览器 bind() 函数：两套参数，两种功能 &emsp;&emsp;bind()方法会创建一个新函数。当这个新函数被调用时，bind()的*第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。 引自 MDN 一个参数：创建一个函数，使这个函数不论怎么调用都有同样的 this 值。12345678910111213141516this.x = 9;var module = &#123; x: 81, getX: function() &#123; return this.x &#125;&#125;module.getX()var retrieveX = module.getX // retrieveX 拿到 getX 指针retrieveX() // 等价于 window.retrieveX 结果为 9// bind() 登场var boundGetX = retrieveX.bind(module) // 此处的 module 就是永久绑定到的 this, 注意他会返回一个新的函数boundGetX() //81 两个参数：使一个函数拥有预设的初始参数1234567891011function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]// Create a function with a preset leading argumentvar leadingThirtysevenList = list.bind(undefined, 37);var list2 = leadingThirtysevenList(); // [37]var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3] bind() 的详细讲解 手写 bind()12345function bind(fn, context)&#123; return function ()&#123; return fn.apply(context, arguments); &#125;&#125; 上述代码包含两个知识点： Array.prototype.slice.call(arguments) 可以将一个具有 length 属性的对象转化为数组 当需要传的实参数量少于形参的数量时，可以用 undefined 占位。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://hi.thisisray.me/tags/ES6/"}]},{"title":"Promise","slug":"Promise","date":"2017-03-17T08:24:50.000Z","updated":"2018-10-08T03:26:35.141Z","comments":true,"path":"Promise.html","link":"","permalink":"http://hi.thisisray.me/Promise.html","excerpt":"学学 Promise","text":"学学 Promise Timingfunction passed to .then will never be called synchronously,even with an already-resolved promise. 12Promise.resolve().then(() =&gt; console.log(2));console.log(1) // 1, 2 instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later when the queue is emptied at the end of the current run of the Javascript event loop. 相对于立即调用，被传入的回调函数会被放置到一个 \bmicrotask 队列中，这意味着只有当当前的事件循环结束后才会被调用。","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hi.thisisray.me/tags/javascript/"}]},{"title":"CSS 中的 BFC","slug":"CSS-中的-BFC","date":"2017-03-01T00:56:41.000Z","updated":"2018-10-08T03:26:35.140Z","comments":true,"path":"CSS-中的-BFC.html","link":"","permalink":"http://hi.thisisray.me/CSS-中的-BFC.html","excerpt":"外边距怎么不对？ 重叠了，父容器加个 overflow: hidden; 就行； 父容器怎么没高度了？ 你子元素是不是设置浮动了？这些工作中经常遇到，通常使用清浮动大法就可解决。但是这背后究竟是什么原理呢？","text":"外边距怎么不对？ 重叠了，父容器加个 overflow: hidden; 就行； 父容器怎么没高度了？ 你子元素是不是设置浮动了？这些工作中经常遇到，通常使用清浮动大法就可解决。但是这背后究竟是什么原理呢？ 这一切的始作俑者是一个叫 BFC (Block Formatting Context, 块级格式化上下) 的东西在作祟。 什么是 BFC ？BFC 是一种 CSS 盒模型的渲染规则，既然是规则就只需记住无法解释。 BFC \b\b的渲染规则Block formatting contexts W3C BFC 元素垂直方向上 margin 会重叠。 正值取最大，正负值相加，负负取绝对值最大 BFC元素在页面上是一个独立的容器,外面的元素和里面的元素互不影响。 BFC元素不会和浮动的元素重叠。(这个可以解释两栏自适应) 计算BFC元素的高度时,里面浮动元素的高度也会参与计算 (用来解释overflow:hidden可以清除浮动) BFC \b\b的触发方式 根\b元素 html 浮动元素 float: left / right overflow 不为 visiable display: inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position: absolute、fixed 注意：display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。 拓展三种文档流的定位方案 前端人人都应该理解的盒模型BFC渲染机制","categories":[{"name":"烂笔头","slug":"烂笔头","permalink":"http://hi.thisisray.me/categories/烂笔头/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://hi.thisisray.me/tags/CSS/"}]}]}